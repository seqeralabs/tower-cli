# CLI Documentation Automation

This directory contains tools and data for automated CLI documentation generation and maintenance.

## Overview

The tower-cli documentation automation extracts command metadata and usage examples from the codebase, enriches descriptions to OpenAPI quality standards, and provides structured data for the docs repository to generate comprehensive CLI reference documentation.

## Components

### Production Data Files

#### cli-metadata.json
Structured metadata for all 161 CLI commands extracted from picocli Java annotations.

**Contains:**
- Complete command hierarchy (5 levels deep)
- All options with descriptions, defaults, arity
- Positional parameters
- Resolved mixin classes (22 mixins)

**Usage:** Consumed by docs repository to generate command reference pages

**Generated by:** `scripts/extract-cli-metadata.py`

**Update frequency:** Run after any CLI command/option changes

#### cli-examples.json
Real command usage examples extracted from test files.

**Contains:**
- 208 command invocations from integration tests
- Automatic categorization (success/error/edge-case)
- Test context and response types

**Usage:** Provides real-world examples for documentation

**Generated by:** `scripts/extract-cli-examples.py`

**Update frequency:** Run after test updates or before releases

#### seqera-api-latest-decorated.yaml
OpenAPI specification with overlay decorations for the Seqera Platform API.

**Usage:** Reference for CLI option enrichment (CLI options often map to API fields)

**Source:** Fetched from docs repository

**Update frequency:** When API documentation updates

### Extraction Scripts

#### scripts/extract-cli-metadata.py
Parses Java source files to extract CLI command metadata from picocli annotations.

**Key features:**
- Handles `@Command`, `@Option`, `@Parameters`, `@Mixin` annotations
- Import-based subcommand resolution for cross-package references
- Fully qualified class names prevent collisions
- Deep nesting support (up to 5 levels)

**Usage:**
```bash
python docs/scripts/extract-cli-metadata.py src/main/java > docs/cli-metadata.json
```

**Output:** JSON with complete command hierarchy and option metadata

#### scripts/extract-cli-examples.py
Extracts command examples from test files.

**Key features:**
- Parses `*CmdTest.java` files for `exec()` calls
- Automatic categorization based on test method names
- Captures test context and expected responses

**Usage:**
```bash
python docs/scripts/extract-cli-examples.py src/test/java -o docs/cli-examples.json
```

**Output:** JSON with categorized command examples

## Architecture

### Command Metadata Extraction Flow

```
Java Source Files (@Command, @Option annotations)
         ↓
extract-cli-metadata.py (parses annotations, resolves hierarchy)
         ↓
cli-metadata.json (structured command data)
         ↓
Docs Repository (generates markdown reference pages)
```

### Examples Extraction Flow

```
Test Files (MockServer-based integration tests)
         ↓
extract-cli-examples.py (parses exec() calls)
         ↓
cli-examples.json (categorized examples)
         ↓
Docs Repository (adds examples to reference pages)
```

### CLI Option Enrichment Pattern

**Problem:** CLI help text quality varied (terse descriptions, inconsistent terminology)

**Solution:** Systematic enrichment using API documentation as quality baseline

**Process:**
1. Identify CLI options that map to API request fields
2. Reference OpenAPI spec descriptions for technical accuracy
3. Adapt descriptions for CLI context (add examples, prerequisites, command refs)
4. Apply quality standards (technical precision, practical guidance, security context)
5. Update `@Option` descriptions directly in Java source files
6. Re-run metadata extraction to capture enriched descriptions

**Status:** 593+ option descriptions enriched across 52 files (5 of ~65 command families complete)

**Remaining work:** ~60 command families available for enrichment

**Tool:** Use `/enrich-cli-help` Claude Code skill for systematic enrichment workflow

## Release Automation

### GitHub Actions Workflow

`.github/workflows/trigger-docs-release-update.yml` runs on tower-cli releases.

**Trigger:** `release.published` event

**Actions:**
1. Extract version from release tag (e.g., `v0.9.4` → `0.9.4`)
2. Verify `cli-metadata.json` and `cli-examples.json` exist in release
3. Send repository dispatch event to docs repository with:
   - CLI version
   - Release tag and URL
   - Metadata file URL
   - Release notes

**Docs repository integration:**
- Receives `cli-release` event
- Fetches metadata and examples from tower-cli release tag
- Generates updated CLI reference documentation
- Creates automated PR with changes

**Result:** Zero manual documentation steps after CLI release

## Quality Standards

All enriched CLI option descriptions follow these criteria:

### Technical Precision
- Specify data types, formats, units
- Document constraints and validation rules
- Explain technical requirements clearly

**Example:**
```java
// Before
@Option(names = {"--max"}, description = "Maximum results")

// After
@Option(names = {"--max"}, description = "Maximum number of results to return. Must be between 1-100. Default: 10.")
```

### Practical Guidance
- Include realistic examples
- Reference related commands
- Document prerequisites and dependencies

**Example:**
```java
// Before
@Option(names = {"--work-dir"}, description = "Work directory")

// After
@Option(names = {"--work-dir"}, description = "Nextflow work directory path where workflow intermediate files are stored. Must be an S3 bucket path (e.g., s3://your-bucket/work). Defaults to compute environment work directory if omitted.")
```

### Security Context
- Warn about sensitive fields
- Document data loss implications
- Clarify access requirements

**Example:**
```java
// Before
@Option(names = {"--token"}, description = "Access token")

// After
@Option(names = {"--token"}, description = "Personal access token for authentication. Token will be stored securely and is never logged. Required scopes: workflow:read, workspace:read.")
```

### Operational Clarity
- Explain scope (workspace/organization/user level)
- Document defaults explicitly
- Clarify optional vs required

**Example:**
```java
// Before
@Option(names = {"--workspace"}, description = "Workspace identifier")

// After
@Option(names = {"-w", "--workspace"}, description = "Workspace numeric identifier or name. Filters results to the specified workspace. Defaults to your personal workspace if omitted.")
```

## Contributor Guide

### Enriching CLI Help Text

Use the `/enrich-cli-help` Claude Code skill for systematic enrichment:

```bash
/enrich-cli-help [command-family-name]
```

**Example:** `/enrich-cli-help pipelines`

The skill automates a 4-phase process:
1. **Parallel agent research** - 4 agents analyze codebase, patterns, API mappings
2. **Synthesis & planning** - Identify architecture patterns and enrichment strategy
3. **Manual enrichment** - Apply quality standards to option descriptions
4. **Verification & commit** - Review changes, generate statistics, commit atomically

**Documentation:** See `.claude/skills/enrich-cli-help/` for complete workflow guide

### After Enriching Options

Always re-run metadata extraction to capture enriched descriptions:

```bash
python docs/scripts/extract-cli-metadata.py src/main/java > docs/cli-metadata.json
git add docs/cli-metadata.json src/main/java/**/*.java
git commit -m "Enrich [family] command options with [N] improvements"
```

### Before Each Release

1. **Extract latest metadata:**
   ```bash
   python docs/scripts/extract-cli-metadata.py src/main/java > docs/cli-metadata.json
   ```

2. **Extract latest examples:**
   ```bash
   python docs/scripts/extract-cli-examples.py src/test/java -o docs/cli-examples.json
   ```

3. **Commit both files:**
   ```bash
   git add docs/cli-metadata.json docs/cli-examples.json
   git commit -m "Update CLI metadata and examples for v${VERSION}"
   ```

4. **Create release** - GitHub Actions automatically triggers docs update

## Architecture Patterns

The tower-cli codebase uses two main patterns for CLI options:

### Pattern 1: Platform/Provider Mixin
Used by: compute-envs, credentials

**Characteristics:**
- Options defined in separate Platform/Provider classes
- Classes instantiated as command mixins
- Each platform/provider has unique option sets

**Metadata extraction:** Does NOT automatically capture these options (limitation)

**Enrichment approach:** Manually edit Platform/Provider Java files

**Example:**
```java
// Command class
@Command(name = "add")
class AddCmd {
    @Mixin
    AwsBatchPlatform platform; // Options in separate class
}

// Platform class (separate file)
class AwsBatchPlatform {
    @Option(names = {"--fusion-v2"}, description = "Enable Fusion v2...")
    boolean fusionV2;
}
```

### Pattern 2: Direct Options
Used by: runs, organizations, teams, members, pipelines, workspaces, etc.

**Characteristics:**
- Options defined directly in command class
- Standard picocli pattern

**Metadata extraction:** DOES capture these options

**Enrichment approach:** Edit command class, re-extract metadata

**Example:**
```java
@Command(name = "list")
class ListCmd {
    @Option(names = {"-w", "--workspace"}, description = "Workspace numeric identifier...")
    Long workspaceId;
}
```

## Metrics

### Current State
- **Commands extracted:** 161/161 (100%)
- **Options enriched:** 593+ descriptions
- **Command families enriched:** 5 of ~65
- **Real examples extracted:** 208
- **Remaining enrichment:** ~60 families

### Quality Impact
- **Before:** Inconsistent quality, terse descriptions, missing context
- **After:** OpenAPI-grade standards, technical precision, practical guidance
- **Time savings:** 4-6 hours → 30-60 minutes per release documentation update

## Troubleshooting

### Metadata Extraction Issues

**Problem:** Commands missing from output

**Solution:** Check for:
- Proper `@Command` annotation on class
- Parent command has `subcommands = {ChildCmd.class}` reference
- Import statement if subcommand in different package
- No duplicate class names (use fully qualified names)

**Problem:** Options missing from command

**Solution:**
- Mixin classes: Options won't be extracted automatically
- Check annotation format: `@Option` vs `@CommandLine.Option` (both supported)
- Verify option is not in parent class (check inheritance)

### Examples Extraction Issues

**Problem:** Examples not categorized correctly

**Solution:** Test method naming affects categorization:
- Methods with "error", "fail", "invalid" → error category
- Methods with "empty", "null", "conflict" → edge_case category
- All others → success category

**Problem:** Command parsing fails

**Solution:** Check for:
- `exec()` call format matches expected pattern
- Command arguments properly quoted in test
- MockServer properly configured

## Future Enhancements

### Short Term
- Complete remaining 60 command families enrichment
- Add coverage metrics (which commands have examples vs manual-only)
- Document common option patterns for reuse

### Long Term
- Changelog generation (compare metadata between versions)
- Deprecation tracking (flag removed commands/options)
- Multi-format output (man pages, shell completions)
- Automated enrichment quality checks

## Related Documentation

- **Claude Code skill:** `.claude/skills/enrich-cli-help/SKILL.md`
- **Quality standards:** `.claude/skills/enrich-cli-help/references/quality-standards.md`
- **Architecture patterns:** `.claude/skills/enrich-cli-help/references/architecture-patterns.md`
- **Contributor guide:** `.claude/README.md`
- **API documentation:** https://docs.seqera.io/platform/latest/api/overview
- **CLI documentation:** https://docs.seqera.io/platform/latest/cli/overview
